<!DOCTYPE html>
<meta charset="utf-8">

<link href="{{ url_for('static', filename='./bower_components/keen-dashboards/dist/keen-dashboards.css') }}" rel="stylesheet">
<link href="{{ url_for('static', filename='./bower_components/dcjs/dc.css') }}" rel="stylesheet">
<script src="{{ url_for('static', filename='./bower_components/jquery/dist/jquery.min.js') }}"></script>
<script src="{{ url_for('static', filename='./bower_components/d3/d3.js') }}"></script>
<script src="{{ url_for('static', filename='./bower_components/d3-tip/index.js') }}"></script>
<script src="{{ url_for('static', filename='./bower_components/crossfilter/crossfilter.js') }}"></script>
<script src="{{ url_for('static', filename='./bower_components/reductio/reductio.js') }}"></script>
<script src="{{ url_for('static', filename='./bower_components/moment/moment.js') }}"></script>
<script src="{{ url_for('static', filename='./bower_components/dcjs/dc.js') }}"></script>
<script src="{{ url_for('static', filename='./dashboards.js') }}"></script>

{% extends "layout.html" %} {% block body %}

<style>
  .node {
    cursor: pointer;
  }

  .node:hover {
    stroke: #000;
    stroke-width: 1.5px;
  }

  .node--root {
    stroke: #777;
    stroke-width: 2px;
  }

  .node--leaf {
    fill: white;
    stroke: #777;
    stroke-width: 1px;
  }

.label {
    font: 14px "Helvetica Neue", Helvetica, Arial, sans-serif;
    text-anchor: middle;
    fill: black;
    /*text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff, 0 -1px 0 #fff;*/
    }
    .label, .node--root { pointer-events: none; }
  }

.legend {
  font-size: 12px;
}

rect {
  stroke-width: 2;
}

#ruler {
   visibility: hidden;
   white-space: nowrap;
 }

</style>

<button id="bugs-btn" type="button" class="btn btn-primary btn-sm">Bugs</button>
<button id="temp-coup-btn" type="button" class="btn btn-primary btn-sm">Temporal Coupling</button>
<button id="knowledge-map-btn" type="button" class="btn btn-primary btn-sm">Knowledge Map</button>
<button id="none-btn" type="button" class="btn btn-primary btn-sm">File Info</button>

<div id="circle-packing"></div>
<div id="legend"></div>

<span id="ruler"></span>

<script>
  var packingData = null;
  var PACKING_MODULES = {
    BUGS: 0,
    TEMPORAL_COUPLING: 1,
    CODE_AGE: 2,
    KNOWLEDGE_MAP: 3,
    FILE_INFO: 4
  };
  var mode = PACKING_MODULES.KNOWLEDGE_MAP;

  var projectName = '{{ project_name }}';
  var intervals = {{ intervals | tojson }};

  var authorKey = {};
  var legendDrawn = false;

  if (projectName === null) {
    projectName = this.pathname.split('/').pop();
    alert("project name was null. Setting it to " + projectName); // TODO -- remove this debug line
  }

  var intervalParams = "";
  if (intervals[0]) {
    intervalParams += "&start1=" + intervals[0][0] + "&end1=" + intervals[0][1];
  }
  if (intervals[1]) {
    intervalParams += "&start2=" + intervals[1][0] + "&end2=" + intervals[1][1];
  }

  var requestUrl = "/api/hotspots?project_name=" + projectName + intervalParams;

  console.log('request url: ' + requestUrl);

  var margin = 5,
    outerDiameter = 1000,
    innerDiameter = outerDiameter - margin - margin;

  var x = d3.scale.linear()
    .range([0, innerDiameter]);

  var y = d3.scale.linear()
    .range([0, innerDiameter]);

  var color = d3.scale.linear()
    .domain([-1, 5])
    .range(["hsl(185,60%,99%)", "hsl(187,40%,70%)"])
    .interpolate(d3.interpolateHcl);

  var pack = d3.layout.pack()
    .padding(2)
    .size([innerDiameter, innerDiameter])
    .value(function(d) {
      return d.file_info.loc;
    });

  var svg = d3.select("#circle-packing").append("svg")
    .attr("width", outerDiameter)
    .attr("height", outerDiameter)
    .append("g")
    .attr("transform", "translate(" + margin + "," + margin + ")");

  var tip = d3.tip()
    .attr('class', 'd3-tip')
    .offset([-10, 0])
    .html(function(d) {
      var baseHTML = "<strong style='font-size:18px'>" + d.name +
                     "</strong><br style='line-height:160%'/>"
      switch (mode) {
        case PACKING_MODULES.FILE_INFO:
          // Convert epoch times to dates
          if (!(d.file_info.creation_date instanceof moment)) {
            d.file_info.creation_date = moment(1000 * d.file_info.creation_date);
            d.file_info.last_modified = moment(1000 * d.file_info.last_modified);
          }
          return baseHTML + "<span>Lines of Code: " + d.file_info.loc + "</span>"
                          + "</br><span>Total Revisions: " + d.file_info.total_revisions
                          + "</span></br><span>Creation Date:  "
                          + d.file_info.creation_date.format("M/D/YY")
                          + "</span></br><span> Last Modified:  "
                          + d.file_info.last_modified.format("M/D/YY")
                          + "</span>"
        case PACKING_MODULES.BUGS:
          return baseHTML + "<span>Bug Score: </span><span style='color:red'>"
                          + Math.round(d.bug_info.score*100)/100 + "</span></br>"
                          + "<span>Number of Bugs: " + d.bug_info.count + "</span>";
        case PACKING_MODULES.TEMPORAL_COUPLING:
          var html = baseHTML + "<span>Temporal Coupling Score: </span>";
          if (d.tc_info.score > 0) {
            html += "<span style='color:red'>" + Math.round(d.tc_info.score*100)/100 +
                    "</span></br><span>Number of Revisions: " + d.tc_info.num_revisions + "</span>" +
                    "</span><br/><span>Coupled Module: </span><span style='color:red'>"
                    + d.tc_info.coupled_module + "</span></br>" + "<span>Number of Mutual Revisions: "
                    + d.tc_info.num_mutual_revisions + "</span></br>" + "<span>Percent Coupled: </span>"
                    + "<span style='color:red'>" + Math.round(d.tc_info.percent*100)/100 + "</span>";
          } else {
            html += "<span>" + d.tc_info.score + "</span>";
          }
          return html;
        case PACKING_MODULES.KNOWLEDGE_MAP:
          var sorted_authors = [];
          for (var key in d.knowledge_info.top_authors) { sorted_authors.push([key, d.knowledge_info.top_authors[key]]); }
          sorted_authors.sort(function(a, b) { return b[1] - a[1]; })
          var html = baseHTML + "<strong>Top Contributors</strong>"
                              + "</br style='line-height:135%'><ul style='margin-bottom:0px;'>";
          for (var i in sorted_authors) {
            var author = sorted_authors[i]
            html += "<li><b style='color:" + authorKey[author[0]] + "'>" + author[0] + "</b> with<b> " + author[1] + "</b> changes</li>";
          }
          html += "</ul>";
          return html;
      }
    })

  function drawLegend() {
    if (legendDrawn) {
      console.log("legend already drawn; returning");
      return;
    }
    var offsetX = 5;
    var offsetY = 5;
    var legendWidth = 250;
    var legendHeight = outerDiameter;
    var legendRectSize = 18;
    var legendSpacing = 4;
    var legendSVG = d3.select("#legend").append("svg")
      .attr("width", legendWidth)
      .attr("height", legendHeight)
      .append("g")
      .attr("transform", "translate(" + offsetX + "," + offsetY + ")");
    var legend = legendSVG.selectAll('.legend')
          .data(Object.keys(authorKey))
          .enter()
          .append('g')
          .attr('class', 'legend')
          .attr('transform', function(d, i) {
            var height = legendRectSize + legendSpacing;
            return "translate(" + 0 + "," + i*(height) + ")";
          });
    legend.append('rect')
      .attr('width', legendRectSize)
      .attr('height', legendRectSize)
      .style('fill', function(d){
        return authorKey[d];
      })
      .style('stroke', function(d){
        return authorKey[d];
      });
    legend.append('text')
      .attr('x', legendRectSize + legendSpacing)
      .attr('y', legendRectSize - legendSpacing)
      .text(function(d) { return d; });
    legendDrawn = true;
  }

  function colorCircles() {
    $('#legend').hide();
    switch (mode) {
      case PACKING_MODULES.FILE_INFO:
        svg.selectAll("circle")
          .style("fill", function(d) {
            return d.children ? color(d.depth) : "WhiteSmoke";
          })
          .style("fill-opacity", function(d) {
            return d.children ? color(d.depth) : 1;
          });
          break;
      case PACKING_MODULES.BUGS:
        svg.selectAll("circle")
          .style("fill", function(d) {
            if (d.children) {
              return color(d.depth);
            } else {
              return d.bug_info.score > 0.0 ? "darkred" : "WhiteSmoke";
            }
          })
          .style("fill-opacity", function(d) {
            return d.children ? 1 : d.bug_info.opacity;
          });
          break;
      case PACKING_MODULES.TEMPORAL_COUPLING:
        svg.selectAll("circle")
          .style("fill", function(d) {
            if (d.children) {
              return color(d.depth);
            } else {
              return d.tc_info.color === null ? "WhiteSmoke" : d3.rgb(d.tc_info.color);
            }
          })
          .style("fill-opacity", function(d) {
            return d.children ? 1 : d.tc_info.color === null ? 0 : d.tc_info.opacity;
          });
          break;
      case PACKING_MODULES.KNOWLEDGE_MAP:
        svg.selectAll("circle")
          .style("fill", function(d) {
            if (d.children) {
              return color(d.depth);
            } else {
              if ((d.knowledge_info.color in authorKey) && (authorKey[d.knowledge_info.color] != d.knowledge_info.author)) {
                authorKey[d.knowledge_info.color] = "Other";
              } else {
                authorKey[d.knowledge_info.color] = d.knowledge_info.author;
              }
              return d3.rgb(d.knowledge_info.color);
            }
          })
          .style("fill-opacity", function(d) {
            return d.children ? color(d.depth) : 1;
          });
          // Reverse keys and values for D3 legend
          var reversed = {};
          for (c in authorKey) {
            reversed[authorKey[c]] = c;
          }
          authorKey = reversed;
          drawLegend();
          $('#legend').show();
          break;
    }
  }

  d3.json(requestUrl, function(error, root) {
    root = JSON.parse(root);
    packingData = root;
    console.log(root);
    var focus = root,
      nodes = pack.nodes(root);

    svg.call(tip)

    svg.append("g").selectAll("circle")
      .data(nodes)
      .enter().append("circle")
      .attr("class", function(d) {
        return d.parent ? d.children ? "node" : "node node--leaf" : "node node--root";
      })
      .attr("transform", function(d) {
        return "translate(" + d.x + "," + d.y + ")";
      })
      .attr("r", function(d) {
        return d.r;
      })
      .on("click", function(d) {
        return zoom(focus == d ? root : d);
      });

    svg.append("g").selectAll("text")
      .data(nodes)
      .enter().append("text")
      .attr("class", "label")
      .attr("transform", function(d) {
        return "translate(" + d.x + "," + d.y + ")";
      })
      .style("fill-opacity", function(d) {
        return d.parent === root ? 1 : 0;
      })
      .style("display", function(d) {
        return d.parent === root ? null : "none";
      })
      .style("opacity", function(d) {
        return d.r > 20 ? 1 : 0;
      })
      .style("font-weight", function(d) {
        return d.children ? "bold" : "normal";
      })
      .text(function(d) {
        return d.name;
      });

    svg.selectAll(".node--leaf")
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide);

    function zoom(d, i) {
      // Do not allow leafs to zoom
      if(!d.children) { d = d.parent; }

      var focus0 = focus;
      focus = d;
      var updateCounter = 0;

      var k = innerDiameter / d.r / 2;
      x.domain([d.x - d.r, d.x + d.r]);
      y.domain([d.y - d.r, d.y + d.r]);

      var transition = svg.selectAll("text,circle").transition()
        .duration(d3.event.altKey ? 7500 : 750)
        .attr("transform", function(d) {
          return "translate(" + x(d.x) + "," + y(d.y) + ")";
        });

      transition.filter("circle")
        .attr("r", function(d) {
          return k * d.r;
        });

      transition.filter("text")
        .style("opacity", 0)
        .filter(function(d) {
          return d.parent === focus || d.parent === focus0;
        })
        .style("fill-opacity", function(d) {
          return d.parent === focus ? 1 : 0;
        })
        .each("start", function(d, i) {
          if (d.parent === focus) this.style.display = "inline";
          this.style.opacity = 0;
          updateCounter++;
        })
        .each("end", function(d, i) {
          if (d.parent !== focus) this.style.display = "none";
          updateCounter--;
          if (updateCounter == 0) {
            console.log("time to update labels!");
            adjustLabels(k);
          }
        });

      d3.event.stopPropagation();
    }

    function adjustLabels(k) {
        svg.selectAll("text")
            .style("opacity", function(d) {
                return k * d.r > 20 ? 1 : 0;
            })
            .text(function(d) {
                return d.name;
            })
            .filter(function(d) {
                d.tw = this.getComputedTextLength();
                return (Math.PI*(k*d.r)/2) < d.tw;
            })
            .each(function(d) {
                // Only truncate labels for child elements
                if (d.children) {
                  d3.select(this).text(d.name);
                  return;
                }
                var proposedLabel = d.name;
                var proposedLabelArray = proposedLabel.split('');
                while ((d.tw > (Math.PI*(k*d.r)/2) && proposedLabelArray.length)) {
                    // pull out 3 chars at a time to speed things up (one at a time is too slow)
                    proposedLabelArray.pop();proposedLabelArray.pop(); proposedLabelArray.pop();
                    if (proposedLabelArray.length===0) {
                        proposedLabel = "";
                    } else {
                        proposedLabel = proposedLabelArray.join('') + "..."; // manually truncate with ellipsis
                    }
                    d3.select(this).text(proposedLabel);
                    d.tw = this.getComputedTextLength();
                }
            });
    }

    colorCircles(mode);
  });
  d3.select(self.frameElement).style("height", outerDiameter + "px");

  // Bind Buttons
  $('#temp-coup-btn').on('click', function(e) {
    mode = PACKING_MODULES.TEMPORAL_COUPLING;
    colorCircles();
  });
  $('#bugs-btn').on('click', function(e) {
    mode = PACKING_MODULES.BUGS;
    colorCircles();
  });
  $('#none-btn').on('click', function(e) {
    mode = PACKING_MODULES.FILE_INFO;
    colorCircles();
  });
  $('#knowledge-map-btn').on('click', function(e) {
    mode = PACKING_MODULES.KNOWLEDGE_MAP;
    colorCircles();
  });
</script>


<style>
.d3-tip {
  line-height: 125%;
  font-weight: lighter;
  padding: 8px;
  background: rgba(0, 0, 0, 0.8);
  color: #fff;
  border-radius: 4px;
}

/* Creates a small triangle extender for the tooltip */
.d3-tip:after {
  box-sizing: border-box;
  display: inline;
  font-size: 10px;
  width: 100%;
  line-height: 1;
  color: rgba(0, 0, 0, 0.8);
  content: "\25BC";
  position: absolute;
  text-align: center;
}

/* Style northward tooltips differently */
.d3-tip.n:after {
  margin: -1px 0 0 0;
  top: 100%;
  left: 0;
}

</style>

{% endblock %}
